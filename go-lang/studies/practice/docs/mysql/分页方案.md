# 分页方案

标签: mysql

---

## count(*), count(1), count(0)

* count(expr)为统计expr不为NULL的记录
* count(*)统计所有行
* count(0), count(1)统计所有行

## MyISAM DB

MyISAM 引擎很容易获得总行数的统计，查询速度变得更快。因为 MyISAM 存储引擎已经存储了表的总行数。

MyISAM 会为每张表维护一个 row count 的计数器，每次新增加一行，这个计数器就加 1。但是如果有查询条件，那么 MyISAM 也 game over 了，MyISAM 引擎不支持条件缓存

## 其它DB引擎

受到 MySIAM DB 的启发，我们可以手动维护总数缓存在表的索引中了。

如果 ID 连续，且基本不会断开。直接取最大值 ID

如果表中存在连续的数字列并设为索引，那么通过页码即可计算出此字段的范围，直接作范围查询即可：

```java
start = (page-1)*pagesize+1
end = page*pagesize
select * from table where id >start and id <=end
```

涉及到总数操作，专门维护一个总数。新增一个用户，总数值加 1, 需要总数的时候直接拿这个总数, 比如分页时。如果有多个条件，那么就需要维护多个总数列。该方案的扩展性更好，随着用户表数量增大, 水平切分用户表，要获取用户总数，直接查询这个总数表即可

## 分页正反偏移

数据库自带的 skip 和 limit 的限制条件为我们创建了分页的查询方式，但是如果利用不对，性能会出现千倍万倍差异。

简单一点描述：limit 100000,20 的意思扫描满足条件的 100020 行，扔掉前面的 100000 行，返回最后的 20 行，问题就在这里。如果我反向查询 oder by xx desc limit 0,20，那么我只要索引 20 条数据

这两条 sql 是为查询最后一页的翻页 sql 查询用的。由于一次翻页往往只需要查询较小的数据，如 10 条，但需要向后扫描大量的数据，也就是越往后的翻页查询，扫描的数据量会越多，查询的速度也就越来越慢。

由于查询的数据量大小是固定的，如果查询速度不受翻页的页数影响，或者影响最低，那么这样是最佳的效果了（查询最后最几页的速度和开始几页的速度一致）。

在翻页的时候，往往需要对其中的某个字段做排序（这个字段在索引中），升序排序。那么可不可以利用索引的有序性 来解决上面遇到的问题。

比如有 10000 条数据需要做分页，那么前 5000 条做 asc 排序，后 5000 条 desc 排序，在 limit startnum，pagesize 参数中作出相应的调整。

但是这无疑给应用程序带来复杂，这条 sql 是用于论坛回复帖子的 sql，往往用户在看帖子的时候，一般都是查看前几页和最后几页，那么在翻页的时候最后几页的翻页查询采用 desc 的方式来实现翻页，这样就可以较好的提高性能。

## 游标

如果你知道上一页和下一页的临界值，那么翻页查询也是信手拈来了，直接就告诉了数据库我的起始查询在哪，也就没有什么性能问题了。我更愿意称这个东西为游标 (Cursor)。

如果做下拉刷新，那么就直接避免掉分页的问题了。根据上一页的最后一个值去请求新数据。

## 缓存和不精准

数据量达到一定程度的时候，用户根本就不关心精准的总数, 没人关心差几个。看看知乎、微博、微信订阅号，不精准的统计到处都是

如果每次点击分页的时候都进行一次 count 操作，那速度肯定不会快到哪里去。他们一般也是采用计数器的办法。每次新增加一个粉丝，就把值加 1，直接在用户信息存储一个总数，一段时间后重新查询一次，更新该缓存。这样分页的时候直接拿这个总数进行分页，显示的时候直接显示模糊之就行。
